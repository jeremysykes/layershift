/**
 * Filter template generators — produces complete filter source files.
 *
 * Each generator produces one file in the exported filter, mirroring
 * the parallax filter's architecture (see FILTER_ANATOMY.md).
 *
 * Generated files:
 * - Web Component class (.ts)
 * - Fragment shader (.frag.glsl)
 * - Vertex shader (.vert.glsl)
 * - Bilateral filter shaders (reused from parallax)
 * - Renderer module (.ts)
 * - Type definitions (.ts)
 */

import type { FilterConfig, EffectType } from '../types/filter-config';

// ---------------------------------------------------------------------------
// Web Component generator
// ---------------------------------------------------------------------------

export function generateWebComponent(
  config: FilterConfig,
  kebab: string,
  pascal: string,
): string {
  const tagName = `layershift-${kebab}`;
  const className = `Layershift${pascal}Element`;
  const rendererClass = `${pascal}Renderer`;
  const eventPrefix = tagName;

  return `/**
 * <${tagName}> Web Component
 *
 * A self-contained Custom Element that renders a depth-aware ${config.displayName}
 * video effect. Encapsulates the entire WebGL pipeline inside a Shadow DOM.
 *
 * Generated by Layer Shift Filter Author.
 *
 * Usage:
 *   <${tagName}
 *     src="video.mp4"
 *     depth-src="depth-data.bin"
 *     depth-meta="depth-meta.json"
 *   ></${tagName}>
 */

import {
  DepthFrameInterpolator,
  loadPrecomputedDepth,
  type PrecomputedDepthData,
} from '../../precomputed-depth';
import { analyzeDepthFrames } from '../../depth-analysis';
import { ${rendererClass} } from './${kebab}-renderer';
import type { ParallaxInput } from '../../input-handler';
import type {
  ${className}ReadyDetail,
  ${className}ErrorDetail,
} from './${kebab}.types';

// ---------------------------------------------------------------------------
// Defaults (from authored filter config)
// ---------------------------------------------------------------------------

const DEFAULTS = ${JSON.stringify(getComponentDefaults(config), null, 2).replace(/"/g, "'").replace(/'/g, "'")} as const;

// ---------------------------------------------------------------------------
// Input handler (scoped to component host element)
// ---------------------------------------------------------------------------

class ComponentInputHandler {
  private target: ParallaxInput = { x: 0, y: 0 };
  private smoothed: ParallaxInput = { x: 0, y: 0 };
  private readonly lerpFactor: number;

  constructor(
    private readonly host: HTMLElement,
    lerpFactor = ${config.motion.lerpFactor},
  ) {
    this.lerpFactor = lerpFactor;
    this.host.addEventListener('mousemove', this.handleMouseMove);
    this.host.addEventListener('mouseleave', this.resetTarget);
  }

  update(): ParallaxInput {
    this.smoothed.x += (this.target.x - this.smoothed.x) * this.lerpFactor;
    this.smoothed.y += (this.target.y - this.smoothed.y) * this.lerpFactor;
    return this.smoothed;
  }

  dispose(): void {
    this.host.removeEventListener('mousemove', this.handleMouseMove);
    this.host.removeEventListener('mouseleave', this.resetTarget);
  }

  private readonly handleMouseMove = (e: MouseEvent) => {
    const rect = this.host.getBoundingClientRect();
    this.target.x = Math.max(-1, Math.min(1, ((e.clientX - rect.left) / rect.width) * 2 - 1));
    this.target.y = Math.max(-1, Math.min(1, ((e.clientY - rect.top) / rect.height) * 2 - 1));
  };

  private readonly resetTarget = () => {
    this.target.x = 0;
    this.target.y = 0;
  };
}

// ---------------------------------------------------------------------------
// Custom Element
// ---------------------------------------------------------------------------

export class ${className} extends HTMLElement {
  static readonly TAG_NAME = '${tagName}';

  static get observedAttributes(): string[] {
    return ['src', 'depth-src', 'depth-meta', 'autoplay', 'loop', 'muted'];
  }

  private shadow: ShadowRoot;
  private container: HTMLDivElement | null = null;
  private renderer: ${rendererClass} | null = null;
  private inputHandler: ComponentInputHandler | null = null;
  private initAbortController: AbortController | null = null;

  constructor() {
    super();
    this.shadow = this.attachShadow({ mode: 'open' });
  }

  connectedCallback(): void {
    this.setupShadowDOM();
    if (this.getAttribute('src') && this.getAttribute('depth-src') && this.getAttribute('depth-meta')) {
      void this.doInit();
    }
  }

  disconnectedCallback(): void {
    this.doDispose();
  }

  attributeChangedCallback(): void {
    if (this.isConnected && this.getAttribute('src')) {
      this.doDispose();
      this.setupShadowDOM();
      void this.doInit();
    }
  }

  private setupShadowDOM(): void {
    this.shadow.innerHTML = '';
    const style = document.createElement('style');
    style.textContent = \`
      :host { display: block; width: 100%; height: 100%; position: relative; overflow: hidden; background: #000; }
      .container { width: 100%; height: 100%; position: absolute; inset: 0; }
      canvas { display: block; width: 100%; height: 100%; }
    \`;
    this.shadow.appendChild(style);
    this.container = document.createElement('div');
    this.container.className = 'container';
    this.shadow.appendChild(this.container);
  }

  private async doInit(): Promise<void> {
    if (!this.container) return;
    this.initAbortController?.abort();
    this.initAbortController = new AbortController();
    const signal = this.initAbortController.signal;

    try {
      const src = this.getAttribute('src')!;
      const depthSrc = this.getAttribute('depth-src')!;
      const depthMeta = this.getAttribute('depth-meta')!;
      const isImage = /\\.(jpe?g|png|webp|gif|avif|bmp)(\\?|$)/i.test(src);

      const { createVideoSource, createImageSource } = await import('../../media-source');
      const { loadPrecomputedDepth } = await import('../../precomputed-depth');
      const { DepthFrameInterpolator } = await import('../../precomputed-depth');

      const [source, depthData] = await Promise.all([
        isImage ? createImageSource(src) : createVideoSource(src, { loop: true, muted: true }),
        loadPrecomputedDepth(depthSrc, depthMeta),
      ]);

      if (signal.aborted) { source.dispose(); return; }

      const renderer = new ${rendererClass}(this.container!, ${JSON.stringify(getRendererConfig(config))});
      this.renderer = renderer;
      renderer.initialize(source, depthData.meta.width, depthData.meta.height);

      const interpolator = new DepthFrameInterpolator(depthData);
      this.inputHandler = new ComponentInputHandler(this);
      const inputHandler = this.inputHandler;

      renderer.start(
        source,
        (t: number) => interpolator.sample(t),
        () => {
          const raw = inputHandler.update();
          return { x: raw.x * ${config.motion.sensitivityX}, y: raw.y * ${config.motion.sensitivityY} };
        },
      );

      if (!isImage && source.play) {
        try { await source.play(); } catch { /* autoplay blocked */ }
      }

      this.dispatchEvent(new CustomEvent<${className}ReadyDetail>('${eventPrefix}:ready', {
        detail: { videoWidth: source.width, videoHeight: source.height, duration: source.duration },
        bubbles: true, composed: true,
      }));
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to initialize.';
      console.error('<${tagName}>: init failed', err);
      this.dispatchEvent(new CustomEvent<${className}ErrorDetail>('${eventPrefix}:error', {
        detail: { message },
        bubbles: true, composed: true,
      }));
    }
  }

  private doDispose(): void {
    this.initAbortController?.abort();
    this.renderer?.dispose();
    this.renderer = null;
    this.inputHandler?.dispose();
    this.inputHandler = null;
    this.container = null;
  }
}

// Register
if (!customElements.get(${className}.TAG_NAME)) {
  customElements.define(${className}.TAG_NAME, ${className});
}
`;
}

// ---------------------------------------------------------------------------
// Fragment shader generator
// ---------------------------------------------------------------------------

export function generateFragmentShader(config: FilterConfig): string {
  switch (config.effectType) {
    case 'parallax':
      return generateParallaxFragShader(config);
    case 'tilt-shift':
      return generateTiltShiftFragShader(config);
    case 'foreground-glow':
      return generateForegroundGlowFragShader(config);
    case 'rack-focus':
      return generateRackFocusFragShader(config);
    case 'custom':
      return generateCustomFragShader(config);
    default:
      return generateParallaxFragShader(config);
  }
}

function generateParallaxFragShader(config: FilterConfig): string {
  const p = config.effectParams as import('../types/filter-config').ParallaxParams;
  return `#version 300 es
precision highp float;

uniform sampler2D uImage;
uniform sampler2D uDepth;
uniform vec2 uOffset;
uniform float uStrength;
uniform bool uPomEnabled;
uniform int uPomSteps;
uniform float uContrastLow;
uniform float uContrastHigh;
uniform float uVerticalReduction;
uniform float uDofStart;
uniform float uDofStrength;
uniform vec2 uImageTexelSize;

in vec2 vUv;
in vec2 vScreenUv;
out vec4 fragColor;

float edgeFade(vec2 uv) {
  float margin = uStrength * 1.5;
  float fadeX = smoothstep(0.0, margin, uv.x) * smoothstep(0.0, margin, 1.0 - uv.x);
  float fadeY = smoothstep(0.0, margin, uv.y) * smoothstep(0.0, margin, 1.0 - uv.y);
  return fadeX * fadeY;
}

vec2 basicDisplace(vec2 uv) {
  float depth = texture(uDepth, uv).r;
  depth = smoothstep(uContrastLow, uContrastHigh, depth);
  float displacement = (1.0 - depth) * uStrength;
  displacement *= edgeFade(uv);
  vec2 offset = uOffset * displacement;
  offset.y *= uVerticalReduction;
  return uv + offset;
}

vec2 pomDisplace(vec2 uv) {
  float layerDepth = 1.0 / float(uPomSteps);
  vec2 scaledOffset = uOffset;
  scaledOffset.y *= uVerticalReduction;
  vec2 deltaUV = scaledOffset * uStrength / float(uPomSteps);
  float currentLayerDepth = 0.0;
  vec2 currentUV = uv;
  float fade = edgeFade(uv);

  for (int i = 0; i < MAX_POM_STEPS; i++) {
    if (i >= uPomSteps) break;
    float rawDepth = texture(uDepth, currentUV).r;
    rawDepth = smoothstep(uContrastLow, uContrastHigh, rawDepth);
    float depthAtUV = 1.0 - rawDepth;
    if (currentLayerDepth > depthAtUV) {
      vec2 prevUV = currentUV - deltaUV;
      float prevLayerDepth = currentLayerDepth - layerDepth;
      float prevRaw = texture(uDepth, prevUV).r;
      prevRaw = smoothstep(uContrastLow, uContrastHigh, prevRaw);
      float prevDepthAtUV = 1.0 - prevRaw;
      float afterDepth = depthAtUV - currentLayerDepth;
      float beforeDepth = prevDepthAtUV - prevLayerDepth;
      float t = afterDepth / (afterDepth - beforeDepth);
      vec2 hitUV = mix(currentUV, prevUV, t);
      return mix(uv, hitUV, fade);
    }
    currentUV += deltaUV;
    currentLayerDepth += layerDepth;
  }
  return mix(uv, currentUV, fade);
}

void main() {
  vec2 displaced = uPomEnabled ? pomDisplace(vUv) : basicDisplace(vUv);
  displaced = clamp(displaced, vec2(0.0), vec2(1.0));
  vec4 color = texture(uImage, displaced);

  // Depth-of-field hint
  float dofDepth = texture(uDepth, displaced).r;
  float dof = smoothstep(uDofStart, 1.0, dofDepth) * uDofStrength;
  vec4 blurred = (
    texture(uImage, displaced + vec2( uImageTexelSize.x,  0.0)) +
    texture(uImage, displaced + vec2(-uImageTexelSize.x,  0.0)) +
    texture(uImage, displaced + vec2( 0.0,  uImageTexelSize.y)) +
    texture(uImage, displaced + vec2( 0.0, -uImageTexelSize.y))
  ) * 0.25;
  color = mix(color, blurred, dof);

  fragColor = color;
}
`;
}

function generateTiltShiftFragShader(config: FilterConfig): string {
  const p = config.effectParams as import('../types/filter-config').TiltShiftParams;
  return `#version 300 es
precision highp float;

uniform sampler2D uImage;
uniform sampler2D uDepth;
uniform vec2 uOffset;
uniform vec2 uImageTexelSize;

// Tilt-shift parameters
uniform float uFocalCenter;     // ${p.focalCenter}
uniform float uFocalWidth;      // ${p.focalWidth}
uniform float uBlurStrength;    // ${p.blurStrength}
uniform float uTransitionSoft;  // ${p.transitionSoftness}
uniform int uBlurSamples;       // ${p.blurSamples}

in vec2 vUv;
in vec2 vScreenUv;
out vec4 fragColor;

void main() {
  float depth = texture(uDepth, vUv).r;

  // Compute distance from focal band
  float halfWidth = uFocalWidth * 0.5;
  float lower = uFocalCenter - halfWidth;
  float upper = uFocalCenter + halfWidth;

  float distFromFocus;
  if (depth < lower) {
    distFromFocus = smoothstep(lower, lower - uTransitionSoft, depth);
  } else if (depth > upper) {
    distFromFocus = smoothstep(upper, upper + uTransitionSoft, depth);
  } else {
    distFromFocus = 0.0;
  }

  float blurAmount = distFromFocus * uBlurStrength;

  // Gaussian-approximation blur with depth-dependent radius
  vec4 color = vec4(0.0);
  float totalWeight = 0.0;

  // Box-blur approximation with configurable taps
  float radius = blurAmount * 8.0;
  int samples = max(1, uBlurSamples);

  for (int x = -8; x <= 8; x++) {
    for (int y = -8; y <= 8; y++) {
      if (abs(x) > samples / 2 || abs(y) > samples / 2) continue;
      vec2 offset = vec2(float(x), float(y)) * uImageTexelSize * radius;
      float weight = 1.0 - length(vec2(float(x), float(y))) / float(samples);
      weight = max(weight, 0.0);
      color += texture(uImage, vUv + offset) * weight;
      totalWeight += weight;
    }
  }

  fragColor = color / max(totalWeight, 1.0);
}
`;
}

function generateForegroundGlowFragShader(config: FilterConfig): string {
  const p = config.effectParams as import('../types/filter-config').ForegroundGlowParams;
  return `#version 300 es
precision highp float;

uniform sampler2D uImage;
uniform sampler2D uDepth;
uniform vec2 uOffset;
uniform vec2 uImageTexelSize;

// Foreground glow parameters
uniform float uGlowThreshold;   // ${p.glowThreshold}
uniform float uGlowIntensity;   // ${p.glowIntensity}
uniform vec3 uGlowColor;        // vec3(${p.glowColor.join(', ')})
uniform float uGlowRadius;      // ${p.glowRadius}
uniform float uEdgeSoftness;    // ${p.edgeSoftness}

in vec2 vUv;
in vec2 vScreenUv;
out vec4 fragColor;

void main() {
  vec4 color = texture(uImage, vUv);
  float depth = texture(uDepth, vUv).r;

  // Glow mask: near-depth pixels (low depth values = foreground)
  float glowMask = smoothstep(uGlowThreshold + uEdgeSoftness, uGlowThreshold - uEdgeSoftness, depth);

  // Sample nearby depth values for a soft glow spread
  float spreadMask = 0.0;
  float spreadSamples = 0.0;
  for (int x = -3; x <= 3; x++) {
    for (int y = -3; y <= 3; y++) {
      vec2 offset = vec2(float(x), float(y)) * uImageTexelSize * uGlowRadius * 100.0;
      float d = texture(uDepth, vUv + offset).r;
      spreadMask += smoothstep(uGlowThreshold + uEdgeSoftness, uGlowThreshold - uEdgeSoftness, d);
      spreadSamples += 1.0;
    }
  }
  spreadMask /= spreadSamples;

  // Combine: glow from foreground pixels, spread to neighbors
  float finalGlow = max(glowMask, spreadMask * 0.5) * uGlowIntensity;
  vec3 glowContribution = uGlowColor * finalGlow;

  fragColor = vec4(color.rgb + glowContribution, color.a);
}
`;
}

function generateRackFocusFragShader(config: FilterConfig): string {
  const p = config.effectParams as import('../types/filter-config').RackFocusParams;
  return `#version 300 es
precision highp float;

uniform sampler2D uImage;
uniform sampler2D uDepth;
uniform vec2 uOffset;
uniform vec2 uImageTexelSize;

// Rack focus parameters
uniform float uFocusStart;      // ${p.focusStart}
uniform float uFocusEnd;        // ${p.focusEnd}
uniform float uRackProgress;    // 0.0 to 1.0 (animated by renderer)
uniform float uFocalWidth;      // ${p.focalWidth}
uniform float uBlurStrength;    // ${p.blurStrength}

in vec2 vUv;
in vec2 vScreenUv;
out vec4 fragColor;

void main() {
  float depth = texture(uDepth, vUv).r;

  // Interpolate focal center based on rack progress
  float focalCenter = mix(uFocusStart, uFocusEnd, uRackProgress);
  float halfWidth = uFocalWidth * 0.5;

  // Distance from current focal plane
  float dist = abs(depth - focalCenter);
  float blurAmount = smoothstep(halfWidth * 0.5, halfWidth, dist) * uBlurStrength;

  // Blur with depth-dependent radius
  vec4 color = vec4(0.0);
  float totalWeight = 0.0;
  float radius = blurAmount * 6.0;

  for (int x = -4; x <= 4; x++) {
    for (int y = -4; y <= 4; y++) {
      vec2 offset = vec2(float(x), float(y)) * uImageTexelSize * radius;
      float weight = 1.0 - length(vec2(float(x), float(y))) / 6.0;
      weight = max(weight, 0.0);
      color += texture(uImage, vUv + offset) * weight;
      totalWeight += weight;
    }
  }

  fragColor = color / max(totalWeight, 1.0);
}
`;
}

function generateCustomFragShader(_config: FilterConfig): string {
  return `#version 300 es
precision highp float;

uniform sampler2D uImage;
uniform sampler2D uDepth;
uniform vec2 uOffset;
uniform vec2 uImageTexelSize;

in vec2 vUv;
in vec2 vScreenUv;
out vec4 fragColor;

// Custom effect — edit this shader to create your own depth-based effect.
// uImage = video texture, uDepth = depth map (0=near, 1=far),
// uOffset = mouse/gyro input [-1,1], vUv = texture coordinates.

void main() {
  vec4 color = texture(uImage, vUv);
  float depth = texture(uDepth, vUv).r;

  // Example: tint based on depth
  // color.rgb = mix(color.rgb, color.rgb * vec3(0.8, 0.9, 1.0), depth);

  fragColor = color;
}
`;
}

// ---------------------------------------------------------------------------
// Vertex shader generator
// ---------------------------------------------------------------------------

export function generateVertexShader(): string {
  return `#version 300 es
in vec2 aPosition;

uniform vec2 uUvOffset;
uniform vec2 uUvScale;

out vec2 vUv;
out vec2 vScreenUv;

void main() {
  vec2 baseUv = aPosition * 0.5 + 0.5;
  vUv = baseUv * uUvScale + uUvOffset;
  vScreenUv = baseUv;
  gl_Position = vec4(aPosition, 0.0, 1.0);
}
`;
}

// ---------------------------------------------------------------------------
// Bilateral filter shaders (shared — cloned from parallax)
// ---------------------------------------------------------------------------

export function generateBilateralShaders(): { vertex: string; fragment: string } {
  return {
    vertex: `#version 300 es
in vec2 aPosition;
out vec2 vUv;

void main() {
  vUv = aPosition * 0.5 + 0.5;
  gl_Position = vec4(aPosition, 0.0, 1.0);
}
`,
    fragment: `#version 300 es
precision highp float;

// BILATERAL_RADIUS is injected at compile time.
// #define BILATERAL_RADIUS 2

uniform sampler2D uRawDepth;
uniform vec2 uTexelSize;
uniform float uSpatialSigma2;

in vec2 vUv;
out vec4 fragColor;

void main() {
  float center = texture(uRawDepth, vUv).r;
  float totalWeight = 1.0;
  float totalValue = center;

  for (int dx = -BILATERAL_RADIUS; dx <= BILATERAL_RADIUS; dx++) {
    for (int dy = -BILATERAL_RADIUS; dy <= BILATERAL_RADIUS; dy++) {
      if (dx == 0 && dy == 0) continue;
      vec2 offset = vec2(float(dx), float(dy)) * uTexelSize;
      float sample_ = texture(uRawDepth, vUv + offset).r;
      float spatial = exp(-float(dx * dx + dy * dy) / (2.0 * uSpatialSigma2));
      float range_ = exp(-(center - sample_) * (center - sample_) / 0.02);
      float w = spatial * range_;
      totalWeight += w;
      totalValue += sample_ * w;
    }
  }

  fragColor = vec4(vec3(totalValue / totalWeight), 1.0);
}
`,
  };
}

// ---------------------------------------------------------------------------
// Renderer generator
// ---------------------------------------------------------------------------

export function generateRenderer(
  config: FilterConfig,
  kebab: string,
  pascal: string,
): string {
  const rendererClass = `${pascal}Renderer`;
  const hasExtraUniforms = config.effectType !== 'parallax';
  const uniformNames = getUniformNames(config.effectType);

  return `/**
 * ${config.displayName} Renderer — WebGL 2 multi-pass pipeline.
 *
 * Generated by Layer Shift Filter Author.
 * Architecture mirrors ParallaxRenderer: bilateral filter pass + effect pass.
 */

import {
  compileShader,
  linkProgram,
  getUniformLocations,
  createFullscreenQuadVao,
} from '../../webgl-utils';
import { TextureRegistry } from '../../render-pass';
import type { TextureSlot } from '../../render-pass';
import { resolveQuality } from '../../quality';
import { RendererBase } from '../../renderer-base';
import type { MediaSource } from '../../media-source';

import VERTEX_SHADER from './${kebab}.vert.glsl?raw';
import FRAGMENT_SHADER from './${kebab}.frag.glsl?raw';
import BILATERAL_VERTEX_SHADER from './bilateral.vert.glsl?raw';
import BILATERAL_FRAGMENT_SHADER from './bilateral.frag.glsl?raw';

// ---------------------------------------------------------------------------
// Configuration
// ---------------------------------------------------------------------------

export interface ${rendererClass}Config {
${generateConfigInterface(config)}
}

// ---------------------------------------------------------------------------
// Renderer
// ---------------------------------------------------------------------------

const BILATERAL_UNIFORM_NAMES = ['uRawDepth', 'uTexelSize', 'uSpatialSigma2'] as const;
const EFFECT_UNIFORM_NAMES = [${uniformNames.map((n) => `'${n}'`).join(', ')}] as const;
const MAX_POM_STEPS = 64;

export class ${rendererClass} extends RendererBase {
  private gl: WebGL2RenderingContext | null = null;
  private quadVao: WebGLVertexArrayObject | null = null;
  private bilateralProgram: WebGLProgram | null = null;
  private bilateralUniforms: Record<string, WebGLUniformLocation | null> = {};
  private bilateralFbo: WebGLFramebuffer | null = null;
  private effectProgram: WebGLProgram | null = null;
  private effectUniforms: Record<string, WebGLUniformLocation | null> = {};
  private readonly textures = new TextureRegistry();
  private readonly videoSlot: TextureSlot;
  private readonly filteredDepthSlot: TextureSlot;
  private readonly rawDepthSlot: TextureSlot;
  private readonly config: ${rendererClass}Config;
${config.effectType === 'rack-focus' ? '  private rackStartTime = 0;\n  private rackActive = false;' : ''}

  constructor(parent: HTMLElement, config: ${rendererClass}Config) {
    super(parent);
    this.videoSlot = this.textures.register('video');
    this.filteredDepthSlot = this.textures.register('filteredDepth');
    this.rawDepthSlot = this.textures.register('rawDepth');
    this.config = config;

    const gl = this.canvas.getContext('webgl2', {
      antialias: false, alpha: false, desynchronized: true, powerPreference: 'high-performance',
    });
    if (!gl) throw new Error('WebGL 2 not supported.');
    this.gl = gl;
    this.qualityParams = resolveQuality(gl);
    gl.clearColor(0, 0, 0, 1);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.disable(gl.DEPTH_TEST);

    this.initGPU();
    this.setupResizeHandling();
  }

  initialize(source: MediaSource, depthWidth: number, depthHeight: number): void {
    const gl = this.gl;
    if (!gl) return;
    this.textures.disposeAll(gl);
    this.videoAspect = source.width / source.height;
    this.clampDepthDimensions(depthWidth, depthHeight, this.qualityParams.depthMaxDim);

    // Video texture (unit 0)
    this.videoSlot.texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.videoSlot.unit);
    gl.bindTexture(gl.TEXTURE_2D, this.videoSlot.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Raw depth texture (unit 2)
    this.rawDepthSlot.texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.rawDepthSlot.unit);
    gl.bindTexture(gl.TEXTURE_2D, this.rawDepthSlot.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.R8, this.depthWidth, this.depthHeight);

    // Filtered depth texture (unit 1)
    this.filteredDepthSlot.texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + this.filteredDepthSlot.unit);
    gl.bindTexture(gl.TEXTURE_2D, this.filteredDepthSlot.texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texStorage2D(gl.TEXTURE_2D, 1, gl.R8, this.depthWidth, this.depthHeight);

    // Bilateral FBO
    this.bilateralFbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.bilateralFbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.filteredDepthSlot.texture, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    // Set bilateral static uniforms
    gl.useProgram(this.bilateralProgram);
    gl.uniform1i(this.bilateralUniforms.uRawDepth!, 2);
    gl.uniform2f(this.bilateralUniforms.uTexelSize!, 1.0 / this.depthWidth, 1.0 / this.depthHeight);
    gl.uniform1f(this.bilateralUniforms.uSpatialSigma2!, 2.25);

    // Set effect static uniforms
    gl.useProgram(this.effectProgram);
    gl.uniform1i(this.effectUniforms.uImage!, 0);
    gl.uniform1i(this.effectUniforms.uDepth!, 1);
${generateStaticUniformSetters(config)}
    gl.uniform2f(this.effectUniforms.uImageTexelSize!, 1.0 / source.width, 1.0 / source.height);

    this.recalculateViewportLayout();
  }

  private initGPU(): void {
    const gl = this.gl;
    if (!gl) return;

    // Bilateral pass
    const bilateralFragSrc = BILATERAL_FRAGMENT_SHADER.replace(
      '#version 300 es', '#version 300 es\\n#define BILATERAL_RADIUS 2',
    );
    const bvs = compileShader(gl, gl.VERTEX_SHADER, BILATERAL_VERTEX_SHADER);
    const bfs = compileShader(gl, gl.FRAGMENT_SHADER, bilateralFragSrc);
    this.bilateralProgram = linkProgram(gl, bvs, bfs);
    this.bilateralUniforms = getUniformLocations(gl, this.bilateralProgram, BILATERAL_UNIFORM_NAMES);

    // Effect pass
${config.effectType === 'parallax' ? `    const effectFragSrc = FRAGMENT_SHADER.replace(
      '#version 300 es', '#version 300 es\\n#define MAX_POM_STEPS ' + MAX_POM_STEPS,
    );` : '    const effectFragSrc = FRAGMENT_SHADER;'}
    const evs = compileShader(gl, gl.VERTEX_SHADER, VERTEX_SHADER);
    const efs = compileShader(gl, gl.FRAGMENT_SHADER, effectFragSrc);
    this.effectProgram = linkProgram(gl, evs, efs);
    this.effectUniforms = getUniformLocations(gl, this.effectProgram, EFFECT_UNIFORM_NAMES);

    this.quadVao = createFullscreenQuadVao(gl, this.effectProgram);
  }

  protected onRenderFrame(): void {
    const gl = this.gl;
    const source = this.mediaSource;
    if (!gl || !this.effectProgram || !this.quadVao) return;
    const imageSource = source?.getImageSource();
    if (!imageSource) return;

    gl.useProgram(this.effectProgram);
    gl.activeTexture(gl.TEXTURE0 + this.videoSlot.unit);
    gl.bindTexture(gl.TEXTURE_2D, this.videoSlot.texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageSource);

    if (!this.rvfcSupported) {
      this.onDepthUpdate(source!.currentTime);
    }

    if (this.readInput) {
      const input = this.readInput();
      gl.uniform2f(this.effectUniforms.uOffset!, -input.x, input.y);
    }
${config.effectType === 'rack-focus' ? `
    // Animate rack focus progress
    if (!this.rackActive) { this.rackStartTime = performance.now() / 1000; this.rackActive = true; }
    const elapsed = performance.now() / 1000 - this.rackStartTime;
    const duration = this.config.rackDuration;
    let progress = ${(config.effectParams as import('../types/filter-config').RackFocusParams).loop ? 'Math.abs(((elapsed / duration) % 2) - 1)' : 'Math.min(elapsed / duration, 1.0)'};
    gl.uniform1f(this.effectUniforms.uRackProgress!, progress);
` : ''}

    gl.bindVertexArray(this.quadVao);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  protected onDepthUpdate(timeSec: number): void {
    const gl = this.gl;
    if (!gl || !this.readDepth || !this.rawDepthSlot.texture || !this.bilateralFbo) return;
    const depthData = this.subsampleDepth(this.readDepth(timeSec));

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, this.rawDepthSlot.texture);
    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.depthWidth, this.depthHeight, gl.RED, gl.UNSIGNED_BYTE, depthData);

    gl.bindFramebuffer(gl.FRAMEBUFFER, this.bilateralFbo);
    gl.viewport(0, 0, this.depthWidth, this.depthHeight);
    gl.useProgram(this.bilateralProgram);
    gl.bindVertexArray(this.quadVao);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, this.canvas.width, this.canvas.height);
  }

  protected recalculateViewportLayout(): void {
    const gl = this.gl;
    if (!gl) return;
    const { width, height } = this.getViewportSize();
    const dpr = Math.min(window.devicePixelRatio, 2);
    const bw = Math.round(width * dpr);
    const bh = Math.round(height * dpr);
    if (this.canvas.width !== bw || this.canvas.height !== bh) {
      this.canvas.width = bw;
      this.canvas.height = bh;
      gl.viewport(0, 0, bw, bh);
    }
    this.computeCoverFitUV(0.05, 0.08);
    if (this.effectProgram) {
      gl.useProgram(this.effectProgram);
      gl.uniform2f(this.effectUniforms.uUvOffset!, this.uvOffset[0], this.uvOffset[1]);
      gl.uniform2f(this.effectUniforms.uUvScale!, this.uvScale[0], this.uvScale[1]);
    }
  }

  protected disposeRenderer(): void {
    this.textures.disposeAll(this.gl!);
    if (this.bilateralProgram) this.gl?.deleteProgram(this.bilateralProgram);
    if (this.effectProgram) this.gl?.deleteProgram(this.effectProgram);
    if (this.bilateralFbo) this.gl?.deleteFramebuffer(this.bilateralFbo);
    if (this.quadVao) this.gl?.deleteVertexArray(this.quadVao);
    if (this.gl) { const ext = this.gl.getExtension('WEBGL_lose_context'); ext?.loseContext(); this.gl = null; }
  }

  protected onContextRestored(): void {
    const gl = this.canvas.getContext('webgl2');
    if (!gl) return;
    this.gl = gl;
    gl.clearColor(0, 0, 0, 1);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    this.initGPU();
  }
}
`;
}

// ---------------------------------------------------------------------------
// Types generator
// ---------------------------------------------------------------------------

export function generateTypes(kebab: string, pascal: string): string {
  const className = `Layershift${pascal}Element`;
  const tagName = `layershift-${kebab}`;

  return `/**
 * Type definitions for <${tagName}>.
 * Generated by Layer Shift Filter Author.
 */

export interface ${className}Props {
  src: string;
  'depth-src': string;
  'depth-meta': string;
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
}

export interface ${className}ReadyDetail {
  videoWidth: number;
  videoHeight: number;
  duration: number;
}

export interface ${className}ErrorDetail {
  message: string;
}

export interface ${className}EventMap {
  '${tagName}:ready': CustomEvent<${className}ReadyDetail>;
  '${tagName}:error': CustomEvent<${className}ErrorDetail>;
}
`;
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function getComponentDefaults(config: FilterConfig): Record<string, unknown> {
  return {
    autoplay: true,
    loop: true,
    muted: true,
  };
}

function getRendererConfig(config: FilterConfig): Record<string, unknown> {
  switch (config.effectType) {
    case 'parallax': {
      const p = config.effectParams as import('../types/filter-config').ParallaxParams;
      return {
        parallaxStrength: p.strength,
        pomEnabled: p.pomEnabled,
        pomSteps: p.pomSteps,
        overscanPadding: config.overscanPadding,
        contrastLow: p.contrastLow,
        contrastHigh: p.contrastHigh,
        verticalReduction: p.verticalReduction,
        dofStart: p.dofStart,
        dofStrength: p.dofStrength,
      };
    }
    case 'tilt-shift': {
      const p = config.effectParams as import('../types/filter-config').TiltShiftParams;
      return {
        focalCenter: p.focalCenter,
        focalWidth: p.focalWidth,
        blurStrength: p.blurStrength,
        blurSamples: p.blurSamples,
        transitionSoftness: p.transitionSoftness,
      };
    }
    case 'foreground-glow': {
      const p = config.effectParams as import('../types/filter-config').ForegroundGlowParams;
      return {
        glowThreshold: p.glowThreshold,
        glowIntensity: p.glowIntensity,
        glowColor: p.glowColor,
        glowRadius: p.glowRadius,
        edgeSoftness: p.edgeSoftness,
      };
    }
    case 'rack-focus': {
      const p = config.effectParams as import('../types/filter-config').RackFocusParams;
      return {
        focusStart: p.focusStart,
        focusEnd: p.focusEnd,
        rackDuration: p.rackDuration,
        focalWidth: p.focalWidth,
        blurStrength: p.blurStrength,
        loop: p.loop,
      };
    }
    default:
      return {};
  }
}

function getUniformNames(effectType: EffectType): string[] {
  const common = ['uImage', 'uDepth', 'uOffset', 'uImageTexelSize', 'uUvOffset', 'uUvScale'];

  switch (effectType) {
    case 'parallax':
      return [...common, 'uStrength', 'uPomEnabled', 'uPomSteps',
        'uContrastLow', 'uContrastHigh', 'uVerticalReduction',
        'uDofStart', 'uDofStrength'];
    case 'tilt-shift':
      return [...common, 'uFocalCenter', 'uFocalWidth', 'uBlurStrength',
        'uTransitionSoft', 'uBlurSamples'];
    case 'foreground-glow':
      return [...common, 'uGlowThreshold', 'uGlowIntensity', 'uGlowColor',
        'uGlowRadius', 'uEdgeSoftness'];
    case 'rack-focus':
      return [...common, 'uFocusStart', 'uFocusEnd', 'uRackProgress',
        'uFocalWidth', 'uBlurStrength'];
    case 'custom':
      return common;
    default:
      return common;
  }
}

function generateConfigInterface(config: FilterConfig): string {
  switch (config.effectType) {
    case 'parallax':
      return `  parallaxStrength: number;
  pomEnabled: boolean;
  pomSteps: number;
  overscanPadding: number;
  contrastLow: number;
  contrastHigh: number;
  verticalReduction: number;
  dofStart: number;
  dofStrength: number;`;
    case 'tilt-shift':
      return `  focalCenter: number;
  focalWidth: number;
  blurStrength: number;
  blurSamples: number;
  transitionSoftness: number;`;
    case 'foreground-glow':
      return `  glowThreshold: number;
  glowIntensity: number;
  glowColor: [number, number, number];
  glowRadius: number;
  edgeSoftness: number;`;
    case 'rack-focus':
      return `  focusStart: number;
  focusEnd: number;
  rackDuration: number;
  focalWidth: number;
  blurStrength: number;
  loop: boolean;`;
    case 'custom':
      return `  // Add custom config fields here.`;
    default:
      return '';
  }
}

function generateStaticUniformSetters(config: FilterConfig): string {
  const indent = '    ';
  switch (config.effectType) {
    case 'parallax': {
      return `${indent}gl.uniform1f(this.effectUniforms.uStrength!, this.config.parallaxStrength);
${indent}gl.uniform1i(this.effectUniforms.uPomEnabled!, this.config.pomEnabled ? 1 : 0);
${indent}gl.uniform1i(this.effectUniforms.uPomSteps!, this.config.pomSteps);
${indent}gl.uniform1f(this.effectUniforms.uContrastLow!, this.config.contrastLow);
${indent}gl.uniform1f(this.effectUniforms.uContrastHigh!, this.config.contrastHigh);
${indent}gl.uniform1f(this.effectUniforms.uVerticalReduction!, this.config.verticalReduction);
${indent}gl.uniform1f(this.effectUniforms.uDofStart!, this.config.dofStart);
${indent}gl.uniform1f(this.effectUniforms.uDofStrength!, this.config.dofStrength);`;
    }
    case 'tilt-shift': {
      return `${indent}gl.uniform1f(this.effectUniforms.uFocalCenter!, this.config.focalCenter);
${indent}gl.uniform1f(this.effectUniforms.uFocalWidth!, this.config.focalWidth);
${indent}gl.uniform1f(this.effectUniforms.uBlurStrength!, this.config.blurStrength);
${indent}gl.uniform1f(this.effectUniforms.uTransitionSoft!, this.config.transitionSoftness);
${indent}gl.uniform1i(this.effectUniforms.uBlurSamples!, this.config.blurSamples);`;
    }
    case 'foreground-glow': {
      return `${indent}gl.uniform1f(this.effectUniforms.uGlowThreshold!, this.config.glowThreshold);
${indent}gl.uniform1f(this.effectUniforms.uGlowIntensity!, this.config.glowIntensity);
${indent}gl.uniform3f(this.effectUniforms.uGlowColor!, this.config.glowColor[0], this.config.glowColor[1], this.config.glowColor[2]);
${indent}gl.uniform1f(this.effectUniforms.uGlowRadius!, this.config.glowRadius);
${indent}gl.uniform1f(this.effectUniforms.uEdgeSoftness!, this.config.edgeSoftness);`;
    }
    case 'rack-focus': {
      return `${indent}gl.uniform1f(this.effectUniforms.uFocusStart!, this.config.focusStart);
${indent}gl.uniform1f(this.effectUniforms.uFocusEnd!, this.config.focusEnd);
${indent}gl.uniform1f(this.effectUniforms.uFocalWidth!, this.config.focalWidth);
${indent}gl.uniform1f(this.effectUniforms.uBlurStrength!, this.config.blurStrength);
${indent}gl.uniform1f(this.effectUniforms.uRackProgress!, 0.0);`;
    }
    case 'custom':
    default:
      return '';
  }
}
